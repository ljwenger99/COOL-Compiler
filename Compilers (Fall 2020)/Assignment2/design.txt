Lucas Wenger

It was quite a journey to figure this assignment out. First, I copied over my v2 from the previous assignment as a starting point. I then (with the help of Tessa) copied over the rest of the tokens in cool and their regular expressions. I added the string and comment methods, copying or basing them on the functions in the simple7 program. I settled on printing strings but ignoring comments. While comments could be printed, since they wouldn't acctually be used in the future in our new program, I decided to ignore them. It took a while to figure out I initially had incorrect regular expressions for comments, but I corrected it once I noticed. 

I also realized after getting an initial output that the tokens had to be listed in a certain order. For instance, */ had to be listed before *. That gave me a good few errors. I also noticed that all of my errors (except the built-in "Unexpected Character" error) stopped the program whenever I got an error. I decided it would be more beneficial if my program could show all of the errors it caught in a run through at once, so I changed my error functions from returning 'ERROR' to changing the type of the token to 'ERROR' and returning None. This seemed to fix the issue. 

I was still having some issues with the potential error in the "Finish" function. Through testing, I realized that the error wouldn't be caught if the final line in a cool file contained an error. I do not know why this is exactly, but to fix it, I added a newline at the end of the cool file. This is ignored, but it ensures that there is not an error on the last line. 

I did not have much experience with generators, so I did not know that a generator could only be iterated through once. This probably caused more grief than anything else. Once I realized that, I tried making copies of the generator, but it didn't work. I should say, I wanted to iterate twice so that the first time I could check for errors, and the second time I could actually write to a new file if there were no errors. I thoght it would be annoying if a new file was created that you couldn't use because there were errors in the original code. For a minute or so, I didn't know what to do, but it occurred to me that I could just store the tokens in a string and only write the string to the document if there were no errors in the original code (hence the 'error' variable). 

I organized all of the outputs as far as I could tell to match the cool--lex outputs I saw online. Initially, I wrote it to just be used in Python, but Silas helped me to figure out how to use the command line. Instead of deleting the code that would allow it to take input using the Python interpreter, I just commented it out. Why waste good code, right?

I filled good.cl with a variety of symbols, comments, etc. just to make sure everything was recognized and tokenized properly. I didn't have much of a system there, I just wanted to make sure all of the major boxes for functionality were checked. I filled bad.py with a variety of errors to check the ones I implemented as well as the ones built in to your lexer. I even added an error on the final line and an excessive amount of opening parenthesis to make sure the newline method worked. 